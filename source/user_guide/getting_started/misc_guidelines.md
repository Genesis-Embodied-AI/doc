# 📝 Misc Guidelines

(随時更新します)

- 可能な限り `genesis.tensor` を使用してください。タブキーをカーネルに渡す際には、 `tensor.assert_contiguous()` を呼び出して、それが連続しているか確認してください。Taichi は連続した外部テンソルのみをサポートします。
- ユーザーに Taichi に関連する使用例を公開しないでください。
- 新しいクラスを追加する場合、インタラクティブデバッグを容易にするために `__repr__()` を実装してください。（例: `genesis/engine/states.py` を参照）
- シミュレーション関連のすべての項目を `genesis.engine` に含めてください。
- `print()` の代わりに `genesis.logger.info()` / `debug()` / `warning()` を使用してください。
- ユーザーには、シーンの状態を頻繁にクエリすることが推奨されず、取得したシーン状態を使用しないことを推奨されます。アクセスされたすべてのシーン状態はシーンレベルのリストに保存され、計算グラフの一部とみなされます。このリストは `scene.reset_grad()` を呼び出すことで解放され、すべての占有されたGPUメモリが解放されます。
- 階層構造 - エンティティの作成を各レベルで抽象化し、それらを統一および独立させます:
    - **物理ソルバー (physics solver)**: 様々な種類をサポートします: MPM, PBD, SPH, FEM, リジッドなど。ユーザーがフロントエンドAPIを変更することなく、柔軟に選択できるようにします。
    - **マテリアル (material)** -> これによりバックエンドの物理ソルバーが決定されます。例: `MPMLiquid`, `SPHLiquid`, `PBDLiquid`, `MPMElastic`, `FEMElastic`など。
    - **ジオメトリ (geom)** -> これはエンティティの幾何学を定義します。形状のプリミティブの一つであるか、メッシュからであるか、またはURDFからである場合があります。これらのジオメトリは使用するソルバーに依存しません。
    - すべての異なるエンティティは同じ `scene.add_entity()` を経由して追加されます。
- **デフォルトのソルバー順序**（コードの一貫性のため）:
    - rigid
    - avatar
    - mpm
    - sph
    - pbd
    - fem
    - sf
- **順序規約**:
    - **クォータニオン**: `[w, x, y, z]`
    - **オイラー角**:
        - **ユーザー入力**: 外部 x-y-z を使用し、`degree` 表記。意味的に直感的です。
            - 解釈: `scipy.Rotation` の `xyz` オーダーを使用します。
        - **内部 xyz**:
            - オイラー角は様々なソースで異なる定義があります。
            - 当ケースでは、オイラー角は内部回転の順序 x-y-z に沿って定義されます（`mujoco` と同じ）。
            - 角速度には回転ベクトルを使用します。
- **`id` vs `idx`**:
    - 各オブジェクトの `uuid` には `id` を使用し、インデックスには `idx` を使用します。
- **`uv` 順序**:
    - `assimp`, `trimesh`: 左下隅からの基準
    - `ours`, `pygltflib`, `luisa`: 左上隅からの基準
- **シミュレーションオプション vs ソルバーオプション**:
    - シミュレーションとソルバー両方に既存するパラメータの場合、ソルバーオプション内のものが優先され、未定義の場合はシミュレーションオプションの値で初期化されます。
    - 推奨方法としては、`dt` はシミュレーションオプションで定義し、すべてのソルバーが同一の時間スケールで操作するのが理想です。ただし、ユーザーは異なるソルバーに異なる`dt` を設定することも可能です。
    - **リジッドソルバー** はステップレベルで動作し、他のソルバーはサブステップレベルで動作します。互換性を確保するため、すべての非リジッドソルバーはシミュレーションオプション内で `substeps` を使用します。
- **リジッドソルバーデザインおよび規約**:
    - **属性**: `*_idx` を使用。例: `link_info.parent_idx`
    - **ループ内のID**: `i_*` を使用します。
    - **カーネルループ内の変数**には以下の規則を使用:
        - 接尾辞略称:
            - `i_l`: リンクID
            - `i_p`: 親リンクID
            - `i_r`: ルートリンクID
            - `i_g`: ジオメトリID
            - `i_d`: 自由度 (dof)
        - 接頭辞:
            - `l_`: リンク
            - `l_info`: `links_info[i_l, i_b]`
            - `g_`: ジオメトリ
            - `p_`: 親
            - ...
    - **インデックスの保存**について:
        - クラスごとにオフセット化されたインデックスを保存しますか（`link`、`geom` など）、ローカルのインデックスのみを保存しますか？
            - 前者を採用します。ユーザーが例えば `entity` をクエリする場合、グローバルリンクインデックスを表示する方が適切です。
            - これは `link`、`geom`、`verts` などのインデックスに適用されます。
        - 各オブジェクトが保存するもの:
            - 親クラス（例: `link` はその `entity` を保存）
            - オフセット後のグローバルインデックス
            - 子要素のオフセット値（例: `geom` は `vert`、`face`、`edge` のオフセットインデックスのみを保存）
    - **ルート vs ベース**:
        - `root` はリンクをツリー構造で使用するため、自然な名称です。一方、`base` はユーザー視点からより情報的です。
        - 内部的には `root` リンク、ドキュメントなどでは `base` リンクを使用します。
    - **ルートポーズ vs q**（現在の設計：変更可能性あり）:
        - アームと単一メッシュの両方について、ロード時に指定される位置とオイラー角度がそのルートポーズとなり、`q` はこれに相対します。
    - **制御インターフェース**:
        - ルート位置は最初のジョイント（固定）が接続するワールド位置と結合されるべきです。
        - 制御を行う場合は速度を指示する必要があります:
            - フリージョイントの場合、速度を上書きすることで問題ありません。
            - 固定ジョイントには自由度がないため、制御は不可能です。
        - 位置制御が必要な場合、PD制御器を記述し速度コマンドに変換します。
        - ルート位置（最初のジョイント位置）を変更可能ですが、推奨されません：
            - 固定ジョイントおよびフリージョイント両方に該当します。
            - 位置を設定すると物理的に矛盾が生じる可能性があります。
            - 固定ジョイントとフリージョイントの違い:
                - フリー自由度は外部影響を受けますが、固定ジョイントは影響を受けません。
    - **MJCF vs URDF**:
        - **MJCF**:
            - XMLは常に `worldbody` を持つためスキップします。
            - 時々 `worldbody` に関連したジオメトリが含まれますが、今は対応しない予定です。
        - **URDF**:
            - `robot` のみを含み、すべてをロードします。
            - 場合によってはロボットがワールドリンクを含む場合があるため、このリンクが `genesis` のワールドにロードされ、そのエンティティのルートリンクとなります。
    - **衝突処理**: 凸形状化されたジオメトリに基づいて保存します:
        - メッシュベースのアセットの場合、メッシュ内のすべてのグループの凸包を生成します:
            - グループは元々のサブメッシュ、または `group_by_material=True` の場合マテリアルごとにグループ化します。
            - 各グループは1つの `RigidGeom` になります。
        - **MJCF**:
            - 各MJジオメトリは1つの `RigidGeom` として凸形状化されます。
        - **URDF**:
            - 複数のリンクを含めることが可能です。各リンクには複数のジオメトリ（衝突用と可視化用）が含まれ、それぞれは1つのプリミティブまたは外部アセットになります。
            - `.obj` が複数のサブメッシュを含める場合、1つのURDFジオメトリが複数のメッシュを持つことが可能です。
            - この最低レベルのメッシュを凸形状化し、各メッシュを `RigidGeom` として保存します。
    - **制御インターフェース設計**:
        - **`base pose` のような概念は明示的に持ちません**:
            - **PyBullet**: 動かせるメッシュは独自のベースリンクを持ち、押されるとベースポーズが変化します。
            - **Genesis**:
                - すべてがワールド（リンク -1）に接続されます。
                - すべてのオブジェクトはルートポーズを保持します。この初期ポーズは変更されません。`q` を計算する際の基準です。
                - 自由に動くオブジェクトは、6自由度を持つフリージョイントでワールドに接続されます。押されるとこの状態は変わりますが、ルートポーズは変わりません。
    - **接頭辞 `v`**:
        - 視覚化に使用されるグローバルパラメータ（視覚ジオメトリ、頂点、エッジ、法線など）用に予約します。
- **`surface.vis_mode`**:
    - **剛体**: サポートされるモードは `['visual', 'collision', 'sdf']`。デフォルトタイプは `visual` です。
    - **変形可能非流体ボディ**: サポートされるモードは `['visual', 'particle', 'recon']`。デフォルトタイプは `visual` です。
        - `visual`: 入力された完全な可視メッシュを内部のパーティクル状態を使ってスキン表示します。
        - `particle`: 内部パーティクルを表示します。入力されたテクスチャが色テクスチャである場合、対応する色が使用されます。画像テクスチャの場合、粒子はテクスチャの `mean_color` を用いて描画されます。
        - `recon`: パーティクルを使用して表面再構築を行います。
    - **流体ボディ**: サポートされるモードは `['particle', 'recon']`。デフォルトタイプは `particle` です。
        - `particle`: 内部パーティクルを表示します。入力されたテクスチャが色テクスチャである場合、対応する色が使用されます。画像テクスチャの場合、粒子はテクスチャの `mean_color` を用いて描画されます。
        - `recon`: パーティクルを使用して表面再構築を行います。